{%-
set namespaces = package_name.split('.')
-%}
#pragma once
#include <tuple>
 
#include "eventuals/grpc/client.h" 
#include "eventuals/generator.h"
#include "eventuals/grpc/server.h"
#include "eventuals/task.h"
#include "eventuals/finally.h"
#include "eventuals/head.h"
#include "eventuals/let.h"
#include "eventuals/then.h"
#include "eventuals/do-all.h"
#include "eventuals/raise.h"
#include "gtest/gtest.h"
#include "eventuals/expected.h"
#include <grpcpp/channel.h>
#include <string>
#include "{{ grpc_pb_header }}"

using eventuals::expected;
using eventuals::DoAll;
using eventuals::Raise;
using eventuals::Finally;
using eventuals::Head;
using eventuals::Let;
using eventuals::Then;
using eventuals::make_unexpected;

using grpc::Status;

using eventuals::grpc::Stream;
using eventuals::grpc::Client;
using eventuals::grpc::ClientCompletionThreadPool;
using stout::Borrowable;

namespace {{ namespaces | join('::') }}::eventuals {

{% for service in services %}
struct {{ service.name }} {
  static constexpr char const* service_full_name() {
    return {{ namespaces | join('::') }}::{{ service.name }}::service_full_name();
  }

  class TypeErasedService : public ::eventuals::grpc::Service {
   public:
    ::eventuals::Task::Of<void> Serve() override;

    char const* name() override {
      return {{ service.name }}::service_full_name();
    }

   protected:
    virtual ~TypeErasedService() = default;
{% for method in service.methods %}
{%- set output_type -%}
    ::eventuals::{#...#}
    {%- if method.server_streaming -%}
        Generator::Of
    {%- else -%}
        Task::Of
    {%- endif -%}
    {#...#}<const {{ method.output_type.split('.') | join('::') }}&>::Raises<std::exception>
{%- endset %}
{%- set input_type -%}
{# Input type does not include pointer #}
    {%- if method.client_streaming -%}
        ::eventuals::grpc::ServerReader<{{ method.input_type.split('.') | join('::') }}>
    {%- else -%}
        {{ method.input_type.split('.') | join('::') }}
    {%- endif -%}
{%- endset %}
    virtual {{ output_type }} TypeErased{{ method.name }}(
        std::tuple<
            TypeErasedService*, // this
            ::grpc::GenericServerContext*,
            {{ input_type }}*>* args) = 0;
{% endfor %}

    private:
{% for method in service.methods %}
    ::eventuals::Task::Of<void> Serve{{ method.name }}();
{% endfor %}    
  };

  template <typename Implementation>
  class Service : public TypeErasedService {

{%- for method in service.methods -%}
{%- set output_type -%}
    ::eventuals::{#...#}
    {%- if method.server_streaming -%}
        Generator::Of
    {%- else -%}
        Task::Of
    {%- endif -%}
    {#...#}<const {{ method.output_type.split('.') | join('::') }}&>::Raises<std::exception>
{%- endset %}
{%- set input_type -%}
{# Input type does not include pointer #}
    {%- if method.client_streaming -%}
        ::eventuals::grpc::ServerReader<{{ method.input_type.split('.') | join('::') }}>
    {%- else -%}
        {{ method.input_type.split('.') | join('::') }}
    {%- endif -%}
{%- endset %}
    {{ output_type }} TypeErased{{ method.name }}(
        std::tuple<
            TypeErasedService*,
            ::grpc::GenericServerContext*,
            {{ input_type }}*>* args) override {
      return [args]() {
{%- if not method.server_streaming and not method.client_streaming %}
{#- No streaming => then and move #}
        return ::eventuals::Then([args]() mutable {
          return std::apply(
              [](auto* implementation, auto* context, auto* request) {
                static_assert(std::is_base_of_v<Service, Implementation>);
                return dynamic_cast<Implementation*>(implementation)
                    ->{{ method.name }}(context, std::move(*request));
              },
              *args);
        });
{%- elif not method.server_streaming and method.client_streaming %}
{#- Client streaming => then #}
        return ::eventuals::Then([args]() mutable {
          return std::apply(
              [](auto* implementation, auto* context, auto* reader) {
                static_assert(std::is_base_of_v<Service, Implementation>);
                return dynamic_cast<Implementation*>(implementation)
                    ->{{ method.name }}(context, *reader);
              },
              *args);
        });
{%- elif method.server_streaming and not method.client_streaming %}
{#- Server streaming => move #}
        return std::apply(
            [](auto* implementation, auto* context, auto* request) {
              static_assert(std::is_base_of_v<Service, Implementation>);
              return dynamic_cast<Implementation*>(implementation)
                  ->{{ method.name }}(context, std::move(*request));
            },
            *args);
{%- elif method.server_streaming and method.client_streaming %}
{#- Bi-directional streaming => neither #}
        return std::apply(
            [](auto* implementation, auto* context, auto* reader) {
              static_assert(std::is_base_of_v<Service, Implementation>);
              return dynamic_cast<Implementation*>(implementation)
                  ->{{ method.name }}(context, *reader);
            },
            *args);
{%- endif %}
      };
    }
{%- endfor %}
  };

  class Client {
    public:
    Client(
      const std::string& target,
      const std::shared_ptr<::grpc::ChannelCredentials>& credentials,
      stout::borrowed_ref<ClientCompletionThreadPool> pool)
        : client_(target, credentials, std::move(pool)) {}

{%- for method in service.methods +%}
{%- set input_type -%}
    {%- if method.client_streaming -%}
        Stream<{{ method.input_type.split('.') | join('::') }}>
    {%- else -%}
        {{ method.input_type.split('.') | join('::') }}
    {%- endif -%}
{%- endset %}
{%- set output_type -%}
    {%- if method.server_streaming -%}
        Stream<{{ method.output_type.split('.') | join('::') }}>
    {%- else -%}
        {{ method.output_type.split('.') | join('::') }}
    {%- endif -%}
{%- endset %}
{%- if not method.server_streaming and not method.client_streaming %}
    auto {{ method.name }}({{ method.input_type.split('.') | join('::') }}&& input) {
        return client_.Call<
        {{ namespaces | join('::') }}::{{ service.name }},
        {{ input_type }},
        {{ output_type }}>("{{ method.name }}")
        >> Then(Let([input = std::move(input)](auto& call) {
            return call.Writer().WriteLast(input)
                >> call.Reader().Read()
                >> Head()
                >> Finally(Let([&](auto& output) {
                        return call.Finish()
                            // TODO: Update the error in `expected` to be std::runtime_error.
                            >> Then([&](Status&& status) -> expected<{{ output_type }}, std::exception_ptr>{
                                if (status.ok()) {
                                    return std::move(output);
                                } else {
                                    return make_unexpected(
                                        std::make_exception_ptr(
                                            "Failed to '{{ service.name }}.{{ method.name}}', "
                                            "received gRPC status " + std::to_string(status.error_code()) +
                                            " and error message " + std::string(status.error_message())));
                                }
                            });
                    }));
            }));
    }
{%- else %}
    auto {{ method.name }}() {
        return client_.Call<
        {{ namespaces | join('::') }}::{{ service.name }},
        {{ input_type }},
        {{ output_type }}>("{{ method.name }}");
    }
{% endif %}
{% endfor %}

    protected:
      ::eventuals::grpc::Client client_;
    };
};
{%- endfor %}

} // namespace {{ namespaces | join('::') }}::eventuals

