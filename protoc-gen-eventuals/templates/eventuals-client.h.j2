#pragma once
{%
set namespaces = package_name.split('.')
-%}
#include "eventuals/grpc/client.h"

#include "{{ pb_header }}"
#include "{{ eventuals_header }}"
#include "eventuals/finally.h"
#include "eventuals/head.h"
#include "eventuals/let.h"
#include "eventuals/then.h"
#include "eventuals/do-all.h"
#include "gtest/gtest.h"

#include <grpcpp/channel.h>
#include <string>

using eventuals::DoAll;
using eventuals::Finally;
using eventuals::Head;
using eventuals::Let;
using eventuals::Then;

using grpc::Status;

using eventuals::grpc::Stream;
using eventuals::grpc::Client;
using eventuals::grpc::CompletionPool;
using stout::Borrowable;
using namespace {{ namespaces | join('::') }}::eventuals;

{% for service in services %}
class {{ service.name }}Client {
public:

  {{ service.name }}Client(
      const std::string& target,
      const std::shared_ptr<::grpc::ChannelCredentials>& credentials,
      stout::borrowed_ref<CompletionPool> pool) : client_(target, credentials, std::move(pool)) {}

{%- for method in service.methods +%}
{%- set input_type -%}
    {%- if method.client_streaming -%}
        Stream<{{ method.input_type.split('.') | join('::') }}>
    {%- else -%}
        {{ method.input_type.split('.') | join('::') }}
    {%- endif -%}
{%- endset %}
{%- set output_type -%}
    {%- if method.server_streaming -%}
        Stream<{{ method.output_type.split('.') | join('::') }}>
    {%- else -%}
        {{ method.output_type.split('.') | join('::') }}
    {%- endif -%}
{%- endset %}
{%- if not method.server_streaming and not method.client_streaming %}
  auto {{ method.name }}({{ method.input_type.split('.') | join('::') }}&& input) {
    return client_.Call<{{ namespaces | join('::') }}::{{ service.name }}, {{ input_type }}, {{ output_type }}>("{{ method.name }}")
      >> Then(Let([input = std::move(input)](auto& call) {
           return call.Writer().WriteLast(input)
               >> call.Reader().Read()
               >> Head()
               >> Finally(Let([&](auto& output) {
                    return call.Finish()
                        >> Then([&](Status&& status) {
                             CHECK(status.ok()) << status.error_code()
                                                << ": "
                                                << status.error_message();
                             return std::move(output);
                           });
                  }));
         }));
  }
{%- else %}
  auto {{ method.name }}() {
    return client_.Call<{{ namespaces | join('::') }}::{{ service.name }}, {{ input_type }}, {{ output_type }}>("{{ method.name }}");
  }
{% endif %}
{% endfor %}

protected:
    Client client_;
};
{%+ endfor %}