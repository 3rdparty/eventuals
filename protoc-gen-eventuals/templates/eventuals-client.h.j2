#pragma once
{%
set namespaces = package_name.split('.')
-%}
#include "eventuals/grpc/client.h"
#include "{{ pb_header }}"
#include "{{ eventuals_header }}"
#include "eventuals/finally.h"
#include "eventuals/head.h"
#include "eventuals/let.h"
#include "eventuals/then.h"
#include "eventuals/do-all.h"
#include "gtest/gtest.h"

#include <grpcpp/channel.h>
#include <string>

using eventuals::DoAll;
using eventuals::Finally;
using eventuals::Head;
using eventuals::Let;
using eventuals::Then;

using grpc::Status;

using eventuals::grpc::Stream;
using eventuals::grpc::Client;
using eventuals::grpc::CompletionPool;
using stout::Borrowable;
using namespace {{ namespaces | join('::') }}::eventuals;

{% for service in services %}
class {{ service.name }}Client {
public:

  {{ service.name }}Client(
      const std::string& target,
      const std::shared_ptr<::grpc::ChannelCredentials>& credentials,
      stout::borrowed_ptr<CompletionPool> pool) : client_(target, credentials, std::move(pool)) {}

{%- for method in service.methods +%}
{%- set input_type -%}
    {%- if method.client_streaming -%}
        Stream<{{ method.input_type.split('.') | join('::') }}>
    {%- else -%}
        {{ method.input_type.split('.') | join('::') }}
    {%- endif -%}
{%- endset %}
{%- set output_type -%}
    {%- if method.server_streaming -%}
        Stream<{{ method.output_type.split('.') | join('::') }}>
    {%- else -%}
        {{ method.output_type.split('.') | join('::') }}
    {%- endif -%}
{%- endset %}
{%- if not method.server_streaming and not method.client_streaming %}
  auto {{ method.name }}({{ method.input_type.split('.') | join('::') }}&& input) {
    return client_.Call<{{ namespaces | join('::') }}::{{ service.name }}, {{ input_type }}, {{ output_type }}>("{{ method.name }}")
      | Then(Let([input = std::move(input)](auto& call) {
           return call.Writer().WriteLast(input)
               | call.Reader().Read()
               | Head()
               | Finally(Let([&](auto& output) {
                    return call.Finish()
                        | Then([&](Status&& status) {
                             CHECK(status.ok()) << status.error_code()
                                                << ": "
                                                << status.error_message();
                             return std::move(output);
                           });
                  }));
         }));
  }
{%- elif not method.server_streaming and method.client_streaming %}
  template <typename F>
  auto {{ method.name }}(F&& stream) {
    static_assert(std::is_invocable_v<F>, "The stream return function should be invocable with no args");
    return client_.Call<{{ namespaces | join('::') }}::{{ service.name }}, {{ input_type }}, {{ output_type }}>("{{ method.name }}")
        | Then(Let(
            [&](auto& call) mutable {
              return Foreach(
                         stream(),
                         ([&](auto&& input) {
                           return call.Writer().Write(input);
                         }))
                  | call.WritesDone()
                  | call.Reader().Read()
                  | Head()
                  | Finally(Let([&](auto& output) {
                       return call.Finish()
                           | Then([&](Status&& status) {
                                CHECK(status.ok()) << status.error_code()
                                                   << ": "
                                                   << status.error_message();
                                CHECK(output);
                                return std::move(output);
                              });
                     }));
            }));
  }
{%- elif method.server_streaming and not method.client_streaming %}
  template <typename F>
  auto {{ method.name }}({{ input_type }}&& input, F&& handle) {
    static_assert(std::is_invocable_v<std::invoke_result_t<F>, {{ method.output_type.split('.') | join('::') }}&&>, "The handle function should be invocable with method output parameter");

    return client_.Call<{{ namespaces | join('::') }}::{{ service.name }}, {{ input_type }}, {{ output_type }}>("{{ method.name }}")
        | Then(Let([&](auto& call) {
             return call.Writer().WriteLast(std::move(input))
                 | Foreach(
                        call.Reader().Read(),
                        handle())
                 | Finally([&](auto) {
                      return call.Finish();
                    })
                 | Then([](Status&& status) {
                      CHECK(status.ok()) << status.error_code()
                                         << ": " << status.error_message();
                    });
           }));
  }
{%- elif method.server_streaming and method.client_streaming %}
template <typename Generate, typename Handle>
  auto {{ method.name }}(Generate&& generate, Handle&& handle) {
    static_assert(
        std::is_invocable_v<Generate>,
        "Stream generating function should be invocable with no arguments passed");

    static_assert(!std::is_invocable_v<Handle>, "Handle function should accept eventuals gRPC call");

    return client_.Call<{{ namespaces | join('::') }}::{{ service.name }}, {{ input_type }}, {{ output_type }}>("{{ method.name }}")
        | Then(Let([&](auto& call) {
             return DoAll(
                        Foreach(
                            generate(),
                            [&](RouteNote input) {
                              return call.Writer().Write(input);
                            })
                            | call.WritesDone(),
                        Foreach(
                            call.Reader().Read(),
                            handle(call)))
                 | Finally([&](auto) {
                      return call.Finish();
                    })
                 | Then([](Status&& status) {
                      CHECK(status.ok()) << status.error_code()
                                         << ": " << status.error_message();
                    });
           }));
  }
{%- endif %}
{% endfor %}
protected:
    Client client_;
};
{%+ endfor %}